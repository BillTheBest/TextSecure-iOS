// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IncomingPushMessageSignal.proto

#ifndef PROTOBUF_IncomingPushMessageSignal_2eproto__INCLUDED
#define PROTOBUF_IncomingPushMessageSignal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace textsecure {
    
    // Internal implementation detail -- do not call these.
    void  protobuf_AddDesc_IncomingPushMessageSignal_2eproto();
    void protobuf_AssignDesc_IncomingPushMessageSignal_2eproto();
    void protobuf_ShutdownFile_IncomingPushMessageSignal_2eproto();
    
    class IncomingPushMessageSignal;
    
    // ===================================================================
    
    class IncomingPushMessageSignal : public ::google::protobuf::Message {
    public:
        IncomingPushMessageSignal();
        virtual ~IncomingPushMessageSignal();
        
        IncomingPushMessageSignal(const IncomingPushMessageSignal& from);
        
        inline IncomingPushMessageSignal& operator=(const IncomingPushMessageSignal& from) {
            CopyFrom(from);
            return *this;
        }
        
        inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
            return _unknown_fields_;
        }
        
        inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
            return &_unknown_fields_;
        }
        
        static const ::google::protobuf::Descriptor* descriptor();
        static const IncomingPushMessageSignal& default_instance();
        
        void Swap(IncomingPushMessageSignal* other);
        
        // implements Message ----------------------------------------------
        
        IncomingPushMessageSignal* New() const;
        void CopyFrom(const ::google::protobuf::Message& from);
        void MergeFrom(const ::google::protobuf::Message& from);
        void CopyFrom(const IncomingPushMessageSignal& from);
        void MergeFrom(const IncomingPushMessageSignal& from);
        void Clear();
        bool IsInitialized() const;
        
        int ByteSize() const;
        bool MergePartialFromCodedStream(
                                         ::google::protobuf::io::CodedInputStream* input);
        void SerializeWithCachedSizes(
                                      ::google::protobuf::io::CodedOutputStream* output) const;
        ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
        int GetCachedSize() const { return _cached_size_; }
    private:
        void SharedCtor();
        void SharedDtor();
        void SetCachedSize(int size) const;
    public:
        
        ::google::protobuf::Metadata GetMetadata() const;
        
        // nested types ----------------------------------------------------
        
        // accessors -------------------------------------------------------
        
        // optional uint32 type = 1;
        inline bool has_type() const;
        inline void clear_type();
        static const int kTypeFieldNumber = 1;
        inline ::google::protobuf::uint32 type() const;
        inline void set_type(::google::protobuf::uint32 value);
        
        // optional string source = 2;
        inline bool has_source() const;
        inline void clear_source();
        static const int kSourceFieldNumber = 2;
        inline const ::std::string& source() const;
        inline void set_source(const ::std::string& value);
        inline void set_source(const char* value);
        inline void set_source(const char* value, size_t size);
        inline ::std::string* mutable_source();
        inline ::std::string* release_source();
        inline void set_allocated_source(::std::string* source);
        
        // optional string relay = 3;
        inline bool has_relay() const;
        inline void clear_relay();
        static const int kRelayFieldNumber = 3;
        inline const ::std::string& relay() const;
        inline void set_relay(const ::std::string& value);
        inline void set_relay(const char* value);
        inline void set_relay(const char* value, size_t size);
        inline ::std::string* mutable_relay();
        inline ::std::string* release_relay();
        inline void set_allocated_relay(::std::string* relay);
        
        // repeated string destinations = 4;
        inline int destinations_size() const;
        inline void clear_destinations();
        static const int kDestinationsFieldNumber = 4;
        inline const ::std::string& destinations(int index) const;
        inline ::std::string* mutable_destinations(int index);
        inline void set_destinations(int index, const ::std::string& value);
        inline void set_destinations(int index, const char* value);
        inline void set_destinations(int index, const char* value, size_t size);
        inline ::std::string* add_destinations();
        inline void add_destinations(const ::std::string& value);
        inline void add_destinations(const char* value);
        inline void add_destinations(const char* value, size_t size);
        inline const ::google::protobuf::RepeatedPtrField< ::std::string>& destinations() const;
        inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_destinations();
        
        // optional uint64 timestamp = 5;
        inline bool has_timestamp() const;
        inline void clear_timestamp();
        static const int kTimestampFieldNumber = 5;
        inline ::google::protobuf::uint64 timestamp() const;
        inline void set_timestamp(::google::protobuf::uint64 value);
        
        // optional bytes message = 6;
        inline bool has_message() const;
        inline void clear_message();
        static const int kMessageFieldNumber = 6;
        inline const ::std::string& message() const;
        inline void set_message(const ::std::string& value);
        inline void set_message(const char* value);
        inline void set_message(const void* value, size_t size);
        inline ::std::string* mutable_message();
        inline ::std::string* release_message();
        inline void set_allocated_message(::std::string* message);
        
        // @@protoc_insertion_point(class_scope:textsecure.IncomingPushMessageSignal)
    private:
        inline void set_has_type();
        inline void clear_has_type();
        inline void set_has_source();
        inline void clear_has_source();
        inline void set_has_relay();
        inline void clear_has_relay();
        inline void set_has_timestamp();
        inline void clear_has_timestamp();
        inline void set_has_message();
        inline void clear_has_message();
        
        ::google::protobuf::UnknownFieldSet _unknown_fields_;
        
        ::std::string* source_;
        ::std::string* relay_;
        ::google::protobuf::RepeatedPtrField< ::std::string> destinations_;
        ::google::protobuf::uint64 timestamp_;
        ::std::string* message_;
        ::google::protobuf::uint32 type_;
        
        mutable int _cached_size_;
        ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
        
        friend void  protobuf_AddDesc_IncomingPushMessageSignal_2eproto();
        friend void protobuf_AssignDesc_IncomingPushMessageSignal_2eproto();
        friend void protobuf_ShutdownFile_IncomingPushMessageSignal_2eproto();
        
        void InitAsDefaultInstance();
        static IncomingPushMessageSignal* default_instance_;
    };
    // ===================================================================
    
    
    // ===================================================================
    
    // IncomingPushMessageSignal
    
    // optional uint32 type = 1;
    inline bool IncomingPushMessageSignal::has_type() const {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void IncomingPushMessageSignal::set_has_type() {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void IncomingPushMessageSignal::clear_has_type() {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void IncomingPushMessageSignal::clear_type() {
        type_ = 0u;
        clear_has_type();
    }
    inline ::google::protobuf::uint32 IncomingPushMessageSignal::type() const {
        return type_;
    }
    inline void IncomingPushMessageSignal::set_type(::google::protobuf::uint32 value) {
        set_has_type();
        type_ = value;
    }
    
    // optional string source = 2;
    inline bool IncomingPushMessageSignal::has_source() const {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void IncomingPushMessageSignal::set_has_source() {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void IncomingPushMessageSignal::clear_has_source() {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void IncomingPushMessageSignal::clear_source() {
        if (source_ != &::google::protobuf::internal::kEmptyString) {
            source_->clear();
        }
        clear_has_source();
    }
    inline const ::std::string& IncomingPushMessageSignal::source() const {
        return *source_;
    }
    inline void IncomingPushMessageSignal::set_source(const ::std::string& value) {
        set_has_source();
        if (source_ == &::google::protobuf::internal::kEmptyString) {
            source_ = new ::std::string;
        }
        source_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_source(const char* value) {
        set_has_source();
        if (source_ == &::google::protobuf::internal::kEmptyString) {
            source_ = new ::std::string;
        }
        source_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_source(const char* value, size_t size) {
        set_has_source();
        if (source_ == &::google::protobuf::internal::kEmptyString) {
            source_ = new ::std::string;
        }
        source_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* IncomingPushMessageSignal::mutable_source() {
        set_has_source();
        if (source_ == &::google::protobuf::internal::kEmptyString) {
            source_ = new ::std::string;
        }
        return source_;
    }
    inline ::std::string* IncomingPushMessageSignal::release_source() {
        clear_has_source();
        if (source_ == &::google::protobuf::internal::kEmptyString) {
            return NULL;
        } else {
            ::std::string* temp = source_;
            source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void IncomingPushMessageSignal::set_allocated_source(::std::string* source) {
        if (source_ != &::google::protobuf::internal::kEmptyString) {
            delete source_;
        }
        if (source) {
            set_has_source();
            source_ = source;
        } else {
            clear_has_source();
            source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }
    
    // optional string relay = 3;
    inline bool IncomingPushMessageSignal::has_relay() const {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void IncomingPushMessageSignal::set_has_relay() {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void IncomingPushMessageSignal::clear_has_relay() {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void IncomingPushMessageSignal::clear_relay() {
        if (relay_ != &::google::protobuf::internal::kEmptyString) {
            relay_->clear();
        }
        clear_has_relay();
    }
    inline const ::std::string& IncomingPushMessageSignal::relay() const {
        return *relay_;
    }
    inline void IncomingPushMessageSignal::set_relay(const ::std::string& value) {
        set_has_relay();
        if (relay_ == &::google::protobuf::internal::kEmptyString) {
            relay_ = new ::std::string;
        }
        relay_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_relay(const char* value) {
        set_has_relay();
        if (relay_ == &::google::protobuf::internal::kEmptyString) {
            relay_ = new ::std::string;
        }
        relay_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_relay(const char* value, size_t size) {
        set_has_relay();
        if (relay_ == &::google::protobuf::internal::kEmptyString) {
            relay_ = new ::std::string;
        }
        relay_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* IncomingPushMessageSignal::mutable_relay() {
        set_has_relay();
        if (relay_ == &::google::protobuf::internal::kEmptyString) {
            relay_ = new ::std::string;
        }
        return relay_;
    }
    inline ::std::string* IncomingPushMessageSignal::release_relay() {
        clear_has_relay();
        if (relay_ == &::google::protobuf::internal::kEmptyString) {
            return NULL;
        } else {
            ::std::string* temp = relay_;
            relay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void IncomingPushMessageSignal::set_allocated_relay(::std::string* relay) {
        if (relay_ != &::google::protobuf::internal::kEmptyString) {
            delete relay_;
        }
        if (relay) {
            set_has_relay();
            relay_ = relay;
        } else {
            clear_has_relay();
            relay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }
    
    // repeated string destinations = 4;
    inline int IncomingPushMessageSignal::destinations_size() const {
        return destinations_.size();
    }
    inline void IncomingPushMessageSignal::clear_destinations() {
        destinations_.Clear();
    }
    inline const ::std::string& IncomingPushMessageSignal::destinations(int index) const {
        return destinations_.Get(index);
    }
    inline ::std::string* IncomingPushMessageSignal::mutable_destinations(int index) {
        return destinations_.Mutable(index);
    }
    inline void IncomingPushMessageSignal::set_destinations(int index, const ::std::string& value) {
        destinations_.Mutable(index)->assign(value);
    }
    inline void IncomingPushMessageSignal::set_destinations(int index, const char* value) {
        destinations_.Mutable(index)->assign(value);
    }
    inline void IncomingPushMessageSignal::set_destinations(int index, const char* value, size_t size) {
        destinations_.Mutable(index)->assign(
                                             reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* IncomingPushMessageSignal::add_destinations() {
        return destinations_.Add();
    }
    inline void IncomingPushMessageSignal::add_destinations(const ::std::string& value) {
        destinations_.Add()->assign(value);
    }
    inline void IncomingPushMessageSignal::add_destinations(const char* value) {
        destinations_.Add()->assign(value);
    }
    inline void IncomingPushMessageSignal::add_destinations(const char* value, size_t size) {
        destinations_.Add()->assign(reinterpret_cast<const char*>(value), size);
    }
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
    IncomingPushMessageSignal::destinations() const {
        return destinations_;
    }
    inline ::google::protobuf::RepeatedPtrField< ::std::string>*
    IncomingPushMessageSignal::mutable_destinations() {
        return &destinations_;
    }
    
    // optional uint64 timestamp = 5;
    inline bool IncomingPushMessageSignal::has_timestamp() const {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void IncomingPushMessageSignal::set_has_timestamp() {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void IncomingPushMessageSignal::clear_has_timestamp() {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void IncomingPushMessageSignal::clear_timestamp() {
        timestamp_ = GOOGLE_ULONGLONG(0);
        clear_has_timestamp();
    }
    inline ::google::protobuf::uint64 IncomingPushMessageSignal::timestamp() const {
        return timestamp_;
    }
    inline void IncomingPushMessageSignal::set_timestamp(::google::protobuf::uint64 value) {
        set_has_timestamp();
        timestamp_ = value;
    }
    
    // optional bytes message = 6;
    inline bool IncomingPushMessageSignal::has_message() const {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void IncomingPushMessageSignal::set_has_message() {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void IncomingPushMessageSignal::clear_has_message() {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void IncomingPushMessageSignal::clear_message() {
        if (message_ != &::google::protobuf::internal::kEmptyString) {
            message_->clear();
        }
        clear_has_message();
    }
    inline const ::std::string& IncomingPushMessageSignal::message() const {
        return *message_;
    }
    inline void IncomingPushMessageSignal::set_message(const ::std::string& value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString) {
            message_ = new ::std::string;
        }
        message_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_message(const char* value) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString) {
            message_ = new ::std::string;
        }
        message_->assign(value);
    }
    inline void IncomingPushMessageSignal::set_message(const void* value, size_t size) {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString) {
            message_ = new ::std::string;
        }
        message_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* IncomingPushMessageSignal::mutable_message() {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString) {
            message_ = new ::std::string;
        }
        return message_;
    }
    inline ::std::string* IncomingPushMessageSignal::release_message() {
        clear_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString) {
            return NULL;
        } else {
            ::std::string* temp = message_;
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void IncomingPushMessageSignal::set_allocated_message(::std::string* message) {
        if (message_ != &::google::protobuf::internal::kEmptyString) {
            delete message_;
        }
        if (message) {
            set_has_message();
            message_ = message;
        } else {
            clear_has_message();
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }
    
    
    // @@protoc_insertion_point(namespace_scope)
    
}  // namespace textsecure

#ifndef SWIG
namespace google {
    namespace protobuf {
        
        
    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IncomingPushMessageSignal_2eproto__INCLUDED
